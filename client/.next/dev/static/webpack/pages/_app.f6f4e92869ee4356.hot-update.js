"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/../scing/devices/deviceErrors.ts":
/*!****************************************!*\
  !*** ../scing/devices/deviceErrors.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CaptureFailedError: () => (/* binding */ CaptureFailedError),\n/* harmony export */   DeviceError: () => (/* binding */ DeviceError),\n/* harmony export */   DevicePolicyDeniedError: () => (/* binding */ DevicePolicyDeniedError),\n/* harmony export */   DeviceUnavailableError: () => (/* binding */ DeviceUnavailableError)\n/* harmony export */ });\nclass DeviceError extends Error {\n    constructor(code, message, data){\n        super(message);\n        this.code = code;\n        this.data = data;\n    }\n}\nclass DevicePolicyDeniedError extends DeviceError {\n    constructor(message = 'DEVICE_POLICY_DENIED', data){\n        super('DEVICE_POLICY_DENIED', message, data);\n    }\n}\nclass DeviceUnavailableError extends DeviceError {\n    constructor(message = 'DEVICE_UNAVAILABLE', data){\n        super('DEVICE_UNAVAILABLE', message, data);\n    }\n}\nclass CaptureFailedError extends DeviceError {\n    constructor(message = 'CAPTURE_FAILED', data){\n        super('CAPTURE_FAILED', message, data);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi9zY2luZy9kZXZpY2VzL2RldmljZUVycm9ycy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQU8sTUFBTUEsb0JBQW9CQztJQUkvQixZQUFZQyxJQUFZLEVBQUVDLE9BQWUsRUFBRUMsSUFBVSxDQUFFO1FBQ3JELEtBQUssQ0FBQ0Q7UUFDTixJQUFJLENBQUNELElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNFLElBQUksR0FBR0E7SUFDZDtBQUNGO0FBRU8sTUFBTUMsZ0NBQWdDTDtJQUMzQyxZQUFZRyxVQUFVLHNCQUFzQixFQUFFQyxJQUFVLENBQUU7UUFDeEQsS0FBSyxDQUFDLHdCQUF3QkQsU0FBU0M7SUFDekM7QUFDRjtBQUVPLE1BQU1FLCtCQUErQk47SUFDMUMsWUFBWUcsVUFBVSxvQkFBb0IsRUFBRUMsSUFBVSxDQUFFO1FBQ3RELEtBQUssQ0FBQyxzQkFBc0JELFNBQVNDO0lBQ3ZDO0FBQ0Y7QUFFTyxNQUFNRywyQkFBMkJQO0lBQ3RDLFlBQVlHLFVBQVUsZ0JBQWdCLEVBQUVDLElBQVUsQ0FBRTtRQUNsRCxLQUFLLENBQUMsa0JBQWtCRCxTQUFTQztJQUNuQztBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG1hc3RlXFxTQ0lOR09TX1dPUktcXFNjaW5nT1NcXHNjaW5nXFxkZXZpY2VzXFxkZXZpY2VFcnJvcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIERldmljZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlOiBzdHJpbmc7XG4gIGRhdGE/OiBhbnk7XG5cbiAgY29uc3RydWN0b3IoY29kZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIGRhdGE/OiBhbnkpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIERldmljZVBvbGljeURlbmllZEVycm9yIGV4dGVuZHMgRGV2aWNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJ0RFVklDRV9QT0xJQ1lfREVOSUVEJywgZGF0YT86IGFueSkge1xuICAgIHN1cGVyKCdERVZJQ0VfUE9MSUNZX0RFTklFRCcsIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZXZpY2VVbmF2YWlsYWJsZUVycm9yIGV4dGVuZHMgRGV2aWNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJ0RFVklDRV9VTkFWQUlMQUJMRScsIGRhdGE/OiBhbnkpIHtcbiAgICBzdXBlcignREVWSUNFX1VOQVZBSUxBQkxFJywgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENhcHR1cmVGYWlsZWRFcnJvciBleHRlbmRzIERldmljZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSA9ICdDQVBUVVJFX0ZBSUxFRCcsIGRhdGE/OiBhbnkpIHtcbiAgICBzdXBlcignQ0FQVFVSRV9GQUlMRUQnLCBtZXNzYWdlLCBkYXRhKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkRldmljZUVycm9yIiwiRXJyb3IiLCJjb2RlIiwibWVzc2FnZSIsImRhdGEiLCJEZXZpY2VQb2xpY3lEZW5pZWRFcnJvciIsIkRldmljZVVuYXZhaWxhYmxlRXJyb3IiLCJDYXB0dXJlRmFpbGVkRXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../scing/devices/deviceErrors.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/../scing/devices/devicePolicy.ts":
/*!****************************************!*\
  !*** ../scing/devices/devicePolicy.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decideDevicePolicy: () => (/* binding */ decideDevicePolicy)\n/* harmony export */ });\nfunction mapEngineToBaneKey(engineId) {\n    switch(engineId){\n        case 'LARI-VISION':\n            return 'vision';\n        case 'LARI-MAPPER':\n            return 'mapper';\n        case 'LARI-DOSE':\n            return 'dose';\n        case 'LARI-PRISM':\n            return 'prism';\n        case 'LARI-ECHO':\n            return 'echo';\n        default:\n            // fall back to a safe default key; unknown engines should be gated explicitly upstream.\n            return 'vision';\n    }\n}\nfunction defaultExternalHardware(deviceKind) {\n    // Conservative defaults: drone/spectrometer/sonar are treated as external hardware.\n    return deviceKind === 'drone' || deviceKind === 'spectrometer' || deviceKind === 'sonar';\n}\nfunction decideDevicePolicy(ctx, req) {\n    const key = mapEngineToBaneKey(req.engineId);\n    const requiresExternalHardware = req.requiresExternalHardware ?? defaultExternalHardware(req.deviceKind);\n    const decision = ctx.entitlements({\n        key,\n        requiredStage: req.requiredStage,\n        requiresExternalHardware,\n        requiresPhysicalControl: req.requiresPhysicalControl\n    });\n    return {\n        allow: !!decision.allow,\n        reason: decision.reason,\n        key,\n        requiredStage: req.requiredStage\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi9zY2luZy9kZXZpY2VzL2RldmljZVBvbGljeS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBSUEsU0FBU0EsbUJBQW1CQyxRQUFvQztJQUM5RCxPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVDtZQUNFLHdGQUF3RjtZQUN4RixPQUFPO0lBQ1g7QUFDRjtBQUVBLFNBQVNDLHdCQUF3QkMsVUFBd0M7SUFDdkUsb0ZBQW9GO0lBQ3BGLE9BQU9BLGVBQWUsV0FBV0EsZUFBZSxrQkFBa0JBLGVBQWU7QUFDbkY7QUFFTyxTQUFTQyxtQkFBbUJDLEdBQWUsRUFBRUMsR0FBbUI7SUFDckUsTUFBTUMsTUFBTVAsbUJBQW1CTSxJQUFJTCxRQUFRO0lBQzNDLE1BQU1PLDJCQUNKRixJQUFJRSx3QkFBd0IsSUFBSU4sd0JBQXdCSSxJQUFJSCxVQUFVO0lBRXhFLE1BQU1NLFdBQVdKLElBQUlLLFlBQVksQ0FBQztRQUNoQ0g7UUFDQUksZUFBZUwsSUFBSUssYUFBYTtRQUNoQ0g7UUFDQUkseUJBQXlCTixJQUFJTSx1QkFBdUI7SUFDdEQ7SUFFQSxPQUFPO1FBQ0xDLE9BQU8sQ0FBQyxDQUFDSixTQUFTSSxLQUFLO1FBQ3ZCQyxRQUFRTCxTQUFTSyxNQUFNO1FBQ3ZCUDtRQUNBSSxlQUFlTCxJQUFJSyxhQUFhO0lBQ2xDO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFzdGVcXFNDSU5HT1NfV09SS1xcU2NpbmdPU1xcc2NpbmdcXGRldmljZXNcXGRldmljZVBvbGljeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEJ1c0NvbnRleHQgfSBmcm9tICcuLi9sYXJpQnVzL2J1c1R5cGVzJztcbmltcG9ydCB0eXBlIHsgQmFuZUtleSB9IGZyb20gJy4uL2JhbmUvYmFuZVR5cGVzJztcbmltcG9ydCB0eXBlIHsgQ2FwdHVyZVJlcXVlc3QsIERldmljZVBvbGljeURlY2lzaW9uIH0gZnJvbSAnLi9kZXZpY2VUeXBlcyc7XG5cbmZ1bmN0aW9uIG1hcEVuZ2luZVRvQmFuZUtleShlbmdpbmVJZDogQ2FwdHVyZVJlcXVlc3RbJ2VuZ2luZUlkJ10pOiBCYW5lS2V5IHtcbiAgc3dpdGNoIChlbmdpbmVJZCkge1xuICAgIGNhc2UgJ0xBUkktVklTSU9OJzpcbiAgICAgIHJldHVybiAndmlzaW9uJztcbiAgICBjYXNlICdMQVJJLU1BUFBFUic6XG4gICAgICByZXR1cm4gJ21hcHBlcic7XG4gICAgY2FzZSAnTEFSSS1ET1NFJzpcbiAgICAgIHJldHVybiAnZG9zZSc7XG4gICAgY2FzZSAnTEFSSS1QUklTTSc6XG4gICAgICByZXR1cm4gJ3ByaXNtJztcbiAgICBjYXNlICdMQVJJLUVDSE8nOlxuICAgICAgcmV0dXJuICdlY2hvJztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZmFsbCBiYWNrIHRvIGEgc2FmZSBkZWZhdWx0IGtleTsgdW5rbm93biBlbmdpbmVzIHNob3VsZCBiZSBnYXRlZCBleHBsaWNpdGx5IHVwc3RyZWFtLlxuICAgICAgcmV0dXJuICd2aXNpb24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRFeHRlcm5hbEhhcmR3YXJlKGRldmljZUtpbmQ6IENhcHR1cmVSZXF1ZXN0WydkZXZpY2VLaW5kJ10pOiBib29sZWFuIHtcbiAgLy8gQ29uc2VydmF0aXZlIGRlZmF1bHRzOiBkcm9uZS9zcGVjdHJvbWV0ZXIvc29uYXIgYXJlIHRyZWF0ZWQgYXMgZXh0ZXJuYWwgaGFyZHdhcmUuXG4gIHJldHVybiBkZXZpY2VLaW5kID09PSAnZHJvbmUnIHx8IGRldmljZUtpbmQgPT09ICdzcGVjdHJvbWV0ZXInIHx8IGRldmljZUtpbmQgPT09ICdzb25hcic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNpZGVEZXZpY2VQb2xpY3koY3R4OiBCdXNDb250ZXh0LCByZXE6IENhcHR1cmVSZXF1ZXN0KTogRGV2aWNlUG9saWN5RGVjaXNpb24ge1xuICBjb25zdCBrZXkgPSBtYXBFbmdpbmVUb0JhbmVLZXkocmVxLmVuZ2luZUlkKTtcbiAgY29uc3QgcmVxdWlyZXNFeHRlcm5hbEhhcmR3YXJlID1cbiAgICByZXEucmVxdWlyZXNFeHRlcm5hbEhhcmR3YXJlID8/IGRlZmF1bHRFeHRlcm5hbEhhcmR3YXJlKHJlcS5kZXZpY2VLaW5kKTtcblxuICBjb25zdCBkZWNpc2lvbiA9IGN0eC5lbnRpdGxlbWVudHMoe1xuICAgIGtleSxcbiAgICByZXF1aXJlZFN0YWdlOiByZXEucmVxdWlyZWRTdGFnZSxcbiAgICByZXF1aXJlc0V4dGVybmFsSGFyZHdhcmUsXG4gICAgcmVxdWlyZXNQaHlzaWNhbENvbnRyb2w6IHJlcS5yZXF1aXJlc1BoeXNpY2FsQ29udHJvbCxcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBhbGxvdzogISFkZWNpc2lvbi5hbGxvdyxcbiAgICByZWFzb246IGRlY2lzaW9uLnJlYXNvbixcbiAgICBrZXksXG4gICAgcmVxdWlyZWRTdGFnZTogcmVxLnJlcXVpcmVkU3RhZ2UsXG4gIH07XG59XG4iXSwibmFtZXMiOlsibWFwRW5naW5lVG9CYW5lS2V5IiwiZW5naW5lSWQiLCJkZWZhdWx0RXh0ZXJuYWxIYXJkd2FyZSIsImRldmljZUtpbmQiLCJkZWNpZGVEZXZpY2VQb2xpY3kiLCJjdHgiLCJyZXEiLCJrZXkiLCJyZXF1aXJlc0V4dGVybmFsSGFyZHdhcmUiLCJkZWNpc2lvbiIsImVudGl0bGVtZW50cyIsInJlcXVpcmVkU3RhZ2UiLCJyZXF1aXJlc1BoeXNpY2FsQ29udHJvbCIsImFsbG93IiwicmVhc29uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../scing/devices/devicePolicy.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/../scing/devices/deviceRouter.ts":
/*!****************************************!*\
  !*** ../scing/devices/deviceRouter.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDeviceRouter: () => (/* binding */ createDeviceRouter)\n/* harmony export */ });\n/* harmony import */ var _capabilityRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./capabilityRegistry */ \"(pages-dir-browser)/../scing/devices/capabilityRegistry.ts\");\n/* harmony import */ var _devicePolicy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./devicePolicy */ \"(pages-dir-browser)/../scing/devices/devicePolicy.ts\");\n/* harmony import */ var _deviceErrors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./deviceErrors */ \"(pages-dir-browser)/../scing/devices/deviceErrors.ts\");\n\n\n\nfunction makeRecordBase(req, status) {\n    const now = new Date().toISOString();\n    return {\n        captureId: req.requestId,\n        requestId: req.requestId,\n        correlationId: req.correlationId,\n        orgId: req.orgId,\n        uid: req.uid,\n        deviceId: req.deviceId,\n        inspectionId: req.inspectionId,\n        engineId: req.engineId,\n        deviceKind: req.deviceKind,\n        captureKind: req.captureKind,\n        capturedAt: now,\n        status\n    };\n}\nfunction createDeviceRouter(params) {\n    const registry = params?.registry ?? (0,_capabilityRegistry__WEBPACK_IMPORTED_MODULE_0__.createCapabilityRegistry)();\n    const providers = new Map();\n    const captureStore = params?.captureStore;\n    const router = {\n        registry,\n        registerProvider: (provider, capability)=>{\n            providers.set(provider.providerId, provider);\n            registry.register({\n                providerId: provider.providerId,\n                capability: {\n                    deviceKind: capability.deviceKind,\n                    captureKinds: capability.captureKinds,\n                    label: capability.label,\n                    requiresExternalHardware: capability.requiresExternalHardware,\n                    requiresPhysicalControl: capability.requiresPhysicalControl\n                }\n            });\n        },\n        capture: async (ctx, req)=>{\n            const policy = (0,_devicePolicy__WEBPACK_IMPORTED_MODULE_1__.decideDevicePolicy)(ctx, req);\n            if (!policy.allow) {\n                const record = {\n                    ...makeRecordBase(req, 'rejected'),\n                    error: {\n                        code: 'DEVICE_POLICY_DENIED',\n                        message: policy.reason\n                    }\n                };\n                throw new _deviceErrors__WEBPACK_IMPORTED_MODULE_2__.DevicePolicyDeniedError(policy.reason, {\n                    record,\n                    policy\n                });\n            }\n            const candidates = registry.findProviders({\n                deviceKind: req.deviceKind,\n                captureKind: req.captureKind\n            });\n            const provider = candidates.map((c)=>providers.get(c.providerId)).find((p)=>!!p && p.supports(req));\n            // No provider available: either queue (if store available) or fail.\n            if (!provider) {\n                const record = {\n                    ...makeRecordBase(req, captureStore ? 'queued' : 'rejected'),\n                    error: captureStore ? {\n                        code: 'CAPTURE_QUEUED',\n                        message: 'NO_PROVIDER_AVAILABLE'\n                    } : {\n                        code: 'DEVICE_UNAVAILABLE',\n                        message: 'NO_PROVIDER_AVAILABLE'\n                    }\n                };\n                if (captureStore) {\n                    await captureStore.enqueue({\n                        queuedAt: new Date().toISOString(),\n                        request: req,\n                        record\n                    });\n                    return {\n                        status: 'queued',\n                        record\n                    };\n                }\n                throw new _deviceErrors__WEBPACK_IMPORTED_MODULE_2__.DeviceUnavailableError('NO_PROVIDER_AVAILABLE', {\n                    record\n                });\n            }\n            try {\n                const res = await provider.capture(req);\n                const record = {\n                    ...makeRecordBase(req, 'ok'),\n                    artifacts: res.artifacts\n                };\n                // If we're offline but we have a store, queue the record for later upload.\n                if (req.mode === 'offline' && captureStore) {\n                    await captureStore.enqueue({\n                        queuedAt: new Date().toISOString(),\n                        request: req,\n                        record\n                    });\n                    return {\n                        status: 'queued',\n                        record\n                    };\n                }\n                return {\n                    status: 'ok',\n                    record\n                };\n            } catch (e) {\n                const record = {\n                    ...makeRecordBase(req, 'rejected'),\n                    error: {\n                        code: 'CAPTURE_FAILED',\n                        message: e?.message ?? 'CAPTURE_FAILED'\n                    }\n                };\n                throw new _deviceErrors__WEBPACK_IMPORTED_MODULE_2__.CaptureFailedError(e?.message ?? 'CAPTURE_FAILED', {\n                    record\n                });\n            }\n        }\n    };\n    return router;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi9zY2luZy9kZXZpY2VzL2RldmljZVJvdXRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ3lGO0FBSXJDO0FBSzVCO0FBaUJ4QixTQUFTSyxlQUFlQyxHQUFtQixFQUFFQyxNQUErQjtJQUMxRSxNQUFNQyxNQUFNLElBQUlDLE9BQU9DLFdBQVc7SUFDbEMsT0FBTztRQUNMQyxXQUFXTCxJQUFJTSxTQUFTO1FBQ3hCQSxXQUFXTixJQUFJTSxTQUFTO1FBQ3hCQyxlQUFlUCxJQUFJTyxhQUFhO1FBQ2hDQyxPQUFPUixJQUFJUSxLQUFLO1FBQ2hCQyxLQUFLVCxJQUFJUyxHQUFHO1FBQ1pDLFVBQVVWLElBQUlVLFFBQVE7UUFDdEJDLGNBQWNYLElBQUlXLFlBQVk7UUFDOUJDLFVBQVVaLElBQUlZLFFBQVE7UUFDdEJDLFlBQVliLElBQUlhLFVBQVU7UUFDMUJDLGFBQWFkLElBQUljLFdBQVc7UUFDNUJDLFlBQVliO1FBQ1pEO0lBQ0Y7QUFDRjtBQUVPLFNBQVNlLG1CQUFtQkMsTUFHbEM7SUFDQyxNQUFNQyxXQUFXRCxRQUFRQyxZQUFZeEIsNkVBQXdCQTtJQUM3RCxNQUFNeUIsWUFBWSxJQUFJQztJQUN0QixNQUFNQyxlQUFlSixRQUFRSTtJQUU3QixNQUFNQyxTQUF1QjtRQUMzQko7UUFDQUssa0JBQWtCLENBQUNDLFVBQVVDO1lBQzNCTixVQUFVTyxHQUFHLENBQUNGLFNBQVNHLFVBQVUsRUFBRUg7WUFDbkNOLFNBQVNVLFFBQVEsQ0FBQztnQkFDaEJELFlBQVlILFNBQVNHLFVBQVU7Z0JBQy9CRixZQUFZO29CQUNWWixZQUFZWSxXQUFXWixVQUFVO29CQUNqQ2dCLGNBQWNKLFdBQVdJLFlBQVk7b0JBQ3JDQyxPQUFPTCxXQUFXSyxLQUFLO29CQUN2QkMsMEJBQTBCTixXQUFXTSx3QkFBd0I7b0JBQzdEQyx5QkFBeUJQLFdBQVdPLHVCQUF1QjtnQkFDN0Q7WUFDRjtRQUNGO1FBQ0FDLFNBQVMsT0FBT0MsS0FBS2xDO1lBQ25CLE1BQU1tQyxTQUFTeEMsaUVBQWtCQSxDQUFDdUMsS0FBS2xDO1lBQ3ZDLElBQUksQ0FBQ21DLE9BQU9DLEtBQUssRUFBRTtnQkFDakIsTUFBTUMsU0FBd0I7b0JBQzVCLEdBQUd0QyxlQUFlQyxLQUFLLFdBQVc7b0JBQ2xDc0MsT0FBTzt3QkFBRUMsTUFBTTt3QkFBd0JDLFNBQVNMLE9BQU9NLE1BQU07b0JBQUM7Z0JBQ2hFO2dCQUNBLE1BQU0sSUFBSTdDLGtFQUF1QkEsQ0FBQ3VDLE9BQU9NLE1BQU0sRUFBRTtvQkFBRUo7b0JBQVFGO2dCQUFPO1lBQ3BFO1lBRUEsTUFBTU8sYUFBYXhCLFNBQVN5QixhQUFhLENBQUM7Z0JBQ3hDOUIsWUFBWWIsSUFBSWEsVUFBVTtnQkFDMUJDLGFBQWFkLElBQUljLFdBQVc7WUFDOUI7WUFDQSxNQUFNVSxXQUFXa0IsV0FDZEUsR0FBRyxDQUFDLENBQUNDLElBQU0xQixVQUFVMkIsR0FBRyxDQUFDRCxFQUFFbEIsVUFBVSxHQUNyQ29CLElBQUksQ0FBQyxDQUFDQyxJQUFNLENBQUMsQ0FBQ0EsS0FBS0EsRUFBRUMsUUFBUSxDQUFDakQ7WUFFakMsb0VBQW9FO1lBQ3BFLElBQUksQ0FBQ3dCLFVBQVU7Z0JBQ2IsTUFBTWEsU0FBd0I7b0JBQzVCLEdBQUd0QyxlQUFlQyxLQUFLcUIsZUFBZSxXQUFXLFdBQVc7b0JBQzVEaUIsT0FBT2pCLGVBQ0g7d0JBQUVrQixNQUFNO3dCQUFrQkMsU0FBUztvQkFBd0IsSUFDM0Q7d0JBQUVELE1BQU07d0JBQXNCQyxTQUFTO29CQUF3QjtnQkFDckU7Z0JBRUEsSUFBSW5CLGNBQWM7b0JBQ2hCLE1BQU1BLGFBQWE2QixPQUFPLENBQUM7d0JBQUVDLFVBQVUsSUFBSWhELE9BQU9DLFdBQVc7d0JBQUlnRCxTQUFTcEQ7d0JBQUtxQztvQkFBTztvQkFDdEYsT0FBTzt3QkFBRXBDLFFBQVE7d0JBQVVvQztvQkFBTztnQkFDcEM7Z0JBRUEsTUFBTSxJQUFJeEMsaUVBQXNCQSxDQUFDLHlCQUF5QjtvQkFBRXdDO2dCQUFPO1lBQ3JFO1lBRUEsSUFBSTtnQkFDRixNQUFNZ0IsTUFBTSxNQUFNN0IsU0FBU1MsT0FBTyxDQUFDakM7Z0JBQ25DLE1BQU1xQyxTQUF3QjtvQkFDNUIsR0FBR3RDLGVBQWVDLEtBQUssS0FBSztvQkFDNUJzRCxXQUFXRCxJQUFJQyxTQUFTO2dCQUMxQjtnQkFFQSwyRUFBMkU7Z0JBQzNFLElBQUl0RCxJQUFJdUQsSUFBSSxLQUFLLGFBQWFsQyxjQUFjO29CQUMxQyxNQUFNQSxhQUFhNkIsT0FBTyxDQUFDO3dCQUFFQyxVQUFVLElBQUloRCxPQUFPQyxXQUFXO3dCQUFJZ0QsU0FBU3BEO3dCQUFLcUM7b0JBQU87b0JBQ3RGLE9BQU87d0JBQUVwQyxRQUFRO3dCQUFVb0M7b0JBQU87Z0JBQ3BDO2dCQUVBLE9BQU87b0JBQUVwQyxRQUFRO29CQUFNb0M7Z0JBQU87WUFDaEMsRUFBRSxPQUFPbUIsR0FBUTtnQkFDZixNQUFNbkIsU0FBd0I7b0JBQzVCLEdBQUd0QyxlQUFlQyxLQUFLLFdBQVc7b0JBQ2xDc0MsT0FBTzt3QkFBRUMsTUFBTTt3QkFBa0JDLFNBQVNnQixHQUFHaEIsV0FBVztvQkFBaUI7Z0JBQzNFO2dCQUNBLE1BQU0sSUFBSTFDLDZEQUFrQkEsQ0FBQzBELEdBQUdoQixXQUFXLGtCQUFrQjtvQkFBRUg7Z0JBQU87WUFDeEU7UUFDRjtJQUNGO0lBRUEsT0FBT2Y7QUFDVCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtYXN0ZVxcU0NJTkdPU19XT1JLXFxTY2luZ09TXFxzY2luZ1xcZGV2aWNlc1xcZGV2aWNlUm91dGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQnVzQ29udGV4dCB9IGZyb20gJy4uL2xhcmlCdXMvYnVzVHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlQ2FwYWJpbGl0eVJlZ2lzdHJ5LCB0eXBlIENhcGFiaWxpdHlSZWdpc3RyeSB9IGZyb20gJy4vY2FwYWJpbGl0eVJlZ2lzdHJ5JztcbmltcG9ydCB0eXBlIHsgQ2FwdHVyZVJlY29yZCwgQ2FwdHVyZVJlcXVlc3QsIENhcHR1cmVSZXN1bHQgfSBmcm9tICcuL2RldmljZVR5cGVzJztcbmltcG9ydCB0eXBlIHsgRGV2aWNlUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycyc7XG5pbXBvcnQgdHlwZSB7IENhcHR1cmVTdG9yZSB9IGZyb20gJy4vY2FwdHVyZVN0b3JlJztcbmltcG9ydCB7IGRlY2lkZURldmljZVBvbGljeSB9IGZyb20gJy4vZGV2aWNlUG9saWN5JztcbmltcG9ydCB7XG4gIERldmljZVBvbGljeURlbmllZEVycm9yLFxuICBEZXZpY2VVbmF2YWlsYWJsZUVycm9yLFxuICBDYXB0dXJlRmFpbGVkRXJyb3IsXG59IGZyb20gJy4vZGV2aWNlRXJyb3JzJztcblxuZXhwb3J0IHR5cGUgRGV2aWNlUm91dGVyID0ge1xuICByZWdpc3RlclByb3ZpZGVyOiAoXG4gICAgcHJvdmlkZXI6IERldmljZVByb3ZpZGVyLFxuICAgIGNhcGFiaWxpdHk6IHtcbiAgICAgIGRldmljZUtpbmQ6IENhcHR1cmVSZXF1ZXN0WydkZXZpY2VLaW5kJ107XG4gICAgICBjYXB0dXJlS2luZHM6IENhcHR1cmVSZXF1ZXN0WydjYXB0dXJlS2luZCddW107XG4gICAgICBsYWJlbD86IHN0cmluZztcbiAgICAgIHJlcXVpcmVzRXh0ZXJuYWxIYXJkd2FyZT86IGJvb2xlYW47XG4gICAgICByZXF1aXJlc1BoeXNpY2FsQ29udHJvbD86IGJvb2xlYW47XG4gICAgfVxuICApID0+IHZvaWQ7XG4gIGNhcHR1cmU6IChjdHg6IEJ1c0NvbnRleHQsIHJlcTogQ2FwdHVyZVJlcXVlc3QpID0+IFByb21pc2U8Q2FwdHVyZVJlc3VsdD47XG4gIHJlZ2lzdHJ5OiBDYXBhYmlsaXR5UmVnaXN0cnk7XG59O1xuXG5mdW5jdGlvbiBtYWtlUmVjb3JkQmFzZShyZXE6IENhcHR1cmVSZXF1ZXN0LCBzdGF0dXM6IENhcHR1cmVSZWNvcmRbJ3N0YXR1cyddKTogQ2FwdHVyZVJlY29yZCB7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgcmV0dXJuIHtcbiAgICBjYXB0dXJlSWQ6IHJlcS5yZXF1ZXN0SWQsXG4gICAgcmVxdWVzdElkOiByZXEucmVxdWVzdElkLFxuICAgIGNvcnJlbGF0aW9uSWQ6IHJlcS5jb3JyZWxhdGlvbklkLFxuICAgIG9yZ0lkOiByZXEub3JnSWQsXG4gICAgdWlkOiByZXEudWlkLFxuICAgIGRldmljZUlkOiByZXEuZGV2aWNlSWQsXG4gICAgaW5zcGVjdGlvbklkOiByZXEuaW5zcGVjdGlvbklkLFxuICAgIGVuZ2luZUlkOiByZXEuZW5naW5lSWQsXG4gICAgZGV2aWNlS2luZDogcmVxLmRldmljZUtpbmQsXG4gICAgY2FwdHVyZUtpbmQ6IHJlcS5jYXB0dXJlS2luZCxcbiAgICBjYXB0dXJlZEF0OiBub3csXG4gICAgc3RhdHVzLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGV2aWNlUm91dGVyKHBhcmFtcz86IHtcbiAgcmVnaXN0cnk/OiBDYXBhYmlsaXR5UmVnaXN0cnk7XG4gIGNhcHR1cmVTdG9yZT86IENhcHR1cmVTdG9yZTtcbn0pOiBEZXZpY2VSb3V0ZXIge1xuICBjb25zdCByZWdpc3RyeSA9IHBhcmFtcz8ucmVnaXN0cnkgPz8gY3JlYXRlQ2FwYWJpbGl0eVJlZ2lzdHJ5KCk7XG4gIGNvbnN0IHByb3ZpZGVycyA9IG5ldyBNYXA8c3RyaW5nLCBEZXZpY2VQcm92aWRlcj4oKTtcbiAgY29uc3QgY2FwdHVyZVN0b3JlID0gcGFyYW1zPy5jYXB0dXJlU3RvcmU7XG5cbiAgY29uc3Qgcm91dGVyOiBEZXZpY2VSb3V0ZXIgPSB7XG4gICAgcmVnaXN0cnksXG4gICAgcmVnaXN0ZXJQcm92aWRlcjogKHByb3ZpZGVyLCBjYXBhYmlsaXR5KSA9PiB7XG4gICAgICBwcm92aWRlcnMuc2V0KHByb3ZpZGVyLnByb3ZpZGVySWQsIHByb3ZpZGVyKTtcbiAgICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyKHtcbiAgICAgICAgcHJvdmlkZXJJZDogcHJvdmlkZXIucHJvdmlkZXJJZCxcbiAgICAgICAgY2FwYWJpbGl0eToge1xuICAgICAgICAgIGRldmljZUtpbmQ6IGNhcGFiaWxpdHkuZGV2aWNlS2luZCxcbiAgICAgICAgICBjYXB0dXJlS2luZHM6IGNhcGFiaWxpdHkuY2FwdHVyZUtpbmRzLFxuICAgICAgICAgIGxhYmVsOiBjYXBhYmlsaXR5LmxhYmVsLFxuICAgICAgICAgIHJlcXVpcmVzRXh0ZXJuYWxIYXJkd2FyZTogY2FwYWJpbGl0eS5yZXF1aXJlc0V4dGVybmFsSGFyZHdhcmUsXG4gICAgICAgICAgcmVxdWlyZXNQaHlzaWNhbENvbnRyb2w6IGNhcGFiaWxpdHkucmVxdWlyZXNQaHlzaWNhbENvbnRyb2wsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNhcHR1cmU6IGFzeW5jIChjdHgsIHJlcSkgPT4ge1xuICAgICAgY29uc3QgcG9saWN5ID0gZGVjaWRlRGV2aWNlUG9saWN5KGN0eCwgcmVxKTtcbiAgICAgIGlmICghcG9saWN5LmFsbG93KSB7XG4gICAgICAgIGNvbnN0IHJlY29yZDogQ2FwdHVyZVJlY29yZCA9IHtcbiAgICAgICAgICAuLi5tYWtlUmVjb3JkQmFzZShyZXEsICdyZWplY3RlZCcpLFxuICAgICAgICAgIGVycm9yOiB7IGNvZGU6ICdERVZJQ0VfUE9MSUNZX0RFTklFRCcsIG1lc3NhZ2U6IHBvbGljeS5yZWFzb24gfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhyb3cgbmV3IERldmljZVBvbGljeURlbmllZEVycm9yKHBvbGljeS5yZWFzb24sIHsgcmVjb3JkLCBwb2xpY3kgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSByZWdpc3RyeS5maW5kUHJvdmlkZXJzKHtcbiAgICAgICAgZGV2aWNlS2luZDogcmVxLmRldmljZUtpbmQsXG4gICAgICAgIGNhcHR1cmVLaW5kOiByZXEuY2FwdHVyZUtpbmQsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2FuZGlkYXRlc1xuICAgICAgICAubWFwKChjKSA9PiBwcm92aWRlcnMuZ2V0KGMucHJvdmlkZXJJZCkpXG4gICAgICAgIC5maW5kKChwKSA9PiAhIXAgJiYgcC5zdXBwb3J0cyhyZXEpKTtcblxuICAgICAgLy8gTm8gcHJvdmlkZXIgYXZhaWxhYmxlOiBlaXRoZXIgcXVldWUgKGlmIHN0b3JlIGF2YWlsYWJsZSkgb3IgZmFpbC5cbiAgICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkOiBDYXB0dXJlUmVjb3JkID0ge1xuICAgICAgICAgIC4uLm1ha2VSZWNvcmRCYXNlKHJlcSwgY2FwdHVyZVN0b3JlID8gJ3F1ZXVlZCcgOiAncmVqZWN0ZWQnKSxcbiAgICAgICAgICBlcnJvcjogY2FwdHVyZVN0b3JlXG4gICAgICAgICAgICA/IHsgY29kZTogJ0NBUFRVUkVfUVVFVUVEJywgbWVzc2FnZTogJ05PX1BST1ZJREVSX0FWQUlMQUJMRScgfVxuICAgICAgICAgICAgOiB7IGNvZGU6ICdERVZJQ0VfVU5BVkFJTEFCTEUnLCBtZXNzYWdlOiAnTk9fUFJPVklERVJfQVZBSUxBQkxFJyB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjYXB0dXJlU3RvcmUpIHtcbiAgICAgICAgICBhd2FpdCBjYXB0dXJlU3RvcmUuZW5xdWV1ZSh7IHF1ZXVlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksIHJlcXVlc3Q6IHJlcSwgcmVjb3JkIH0pO1xuICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ3F1ZXVlZCcsIHJlY29yZCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IERldmljZVVuYXZhaWxhYmxlRXJyb3IoJ05PX1BST1ZJREVSX0FWQUlMQUJMRScsIHsgcmVjb3JkIH0pO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBwcm92aWRlci5jYXB0dXJlKHJlcSk7XG4gICAgICAgIGNvbnN0IHJlY29yZDogQ2FwdHVyZVJlY29yZCA9IHtcbiAgICAgICAgICAuLi5tYWtlUmVjb3JkQmFzZShyZXEsICdvaycpLFxuICAgICAgICAgIGFydGlmYWN0czogcmVzLmFydGlmYWN0cyxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJZiB3ZSdyZSBvZmZsaW5lIGJ1dCB3ZSBoYXZlIGEgc3RvcmUsIHF1ZXVlIHRoZSByZWNvcmQgZm9yIGxhdGVyIHVwbG9hZC5cbiAgICAgICAgaWYgKHJlcS5tb2RlID09PSAnb2ZmbGluZScgJiYgY2FwdHVyZVN0b3JlKSB7XG4gICAgICAgICAgYXdhaXQgY2FwdHVyZVN0b3JlLmVucXVldWUoeyBxdWV1ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLCByZXF1ZXN0OiByZXEsIHJlY29yZCB9KTtcbiAgICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdxdWV1ZWQnLCByZWNvcmQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogJ29rJywgcmVjb3JkIH07XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkOiBDYXB0dXJlUmVjb3JkID0ge1xuICAgICAgICAgIC4uLm1ha2VSZWNvcmRCYXNlKHJlcSwgJ3JlamVjdGVkJyksXG4gICAgICAgICAgZXJyb3I6IHsgY29kZTogJ0NBUFRVUkVfRkFJTEVEJywgbWVzc2FnZTogZT8ubWVzc2FnZSA/PyAnQ0FQVFVSRV9GQUlMRUQnIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRocm93IG5ldyBDYXB0dXJlRmFpbGVkRXJyb3IoZT8ubWVzc2FnZSA/PyAnQ0FQVFVSRV9GQUlMRUQnLCB7IHJlY29yZCB9KTtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiByb3V0ZXI7XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ2FwYWJpbGl0eVJlZ2lzdHJ5IiwiZGVjaWRlRGV2aWNlUG9saWN5IiwiRGV2aWNlUG9saWN5RGVuaWVkRXJyb3IiLCJEZXZpY2VVbmF2YWlsYWJsZUVycm9yIiwiQ2FwdHVyZUZhaWxlZEVycm9yIiwibWFrZVJlY29yZEJhc2UiLCJyZXEiLCJzdGF0dXMiLCJub3ciLCJEYXRlIiwidG9JU09TdHJpbmciLCJjYXB0dXJlSWQiLCJyZXF1ZXN0SWQiLCJjb3JyZWxhdGlvbklkIiwib3JnSWQiLCJ1aWQiLCJkZXZpY2VJZCIsImluc3BlY3Rpb25JZCIsImVuZ2luZUlkIiwiZGV2aWNlS2luZCIsImNhcHR1cmVLaW5kIiwiY2FwdHVyZWRBdCIsImNyZWF0ZURldmljZVJvdXRlciIsInBhcmFtcyIsInJlZ2lzdHJ5IiwicHJvdmlkZXJzIiwiTWFwIiwiY2FwdHVyZVN0b3JlIiwicm91dGVyIiwicmVnaXN0ZXJQcm92aWRlciIsInByb3ZpZGVyIiwiY2FwYWJpbGl0eSIsInNldCIsInByb3ZpZGVySWQiLCJyZWdpc3RlciIsImNhcHR1cmVLaW5kcyIsImxhYmVsIiwicmVxdWlyZXNFeHRlcm5hbEhhcmR3YXJlIiwicmVxdWlyZXNQaHlzaWNhbENvbnRyb2wiLCJjYXB0dXJlIiwiY3R4IiwicG9saWN5IiwiYWxsb3ciLCJyZWNvcmQiLCJlcnJvciIsImNvZGUiLCJtZXNzYWdlIiwicmVhc29uIiwiY2FuZGlkYXRlcyIsImZpbmRQcm92aWRlcnMiLCJtYXAiLCJjIiwiZ2V0IiwiZmluZCIsInAiLCJzdXBwb3J0cyIsImVucXVldWUiLCJxdWV1ZWRBdCIsInJlcXVlc3QiLCJyZXMiLCJhcnRpZmFjdHMiLCJtb2RlIiwiZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../scing/devices/deviceRouter.ts\n"));

/***/ })

});