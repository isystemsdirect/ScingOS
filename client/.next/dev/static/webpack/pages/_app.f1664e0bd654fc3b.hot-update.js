"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/../scing/obs/obsClientQueue.ts":
/*!**************************************!*\
  !*** ../scing/obs/obsClientQueue.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropObs: () => (/* binding */ dropObs),\n/* harmony export */   enqueueObs: () => (/* binding */ enqueueObs),\n/* harmony export */   peekObs: () => (/* binding */ peekObs)\n/* harmony export */ });\nconst KEY = 'scing_obs_queue_v1';\nfunction load() {\n    try {\n        if (typeof localStorage === 'undefined') return [];\n        const raw = localStorage.getItem(KEY);\n        if (!raw) return [];\n        const arr = JSON.parse(raw);\n        return Array.isArray(arr) ? arr : [];\n    } catch  {\n        return [];\n    }\n}\nfunction save(arr) {\n    try {\n        if (typeof localStorage === 'undefined') return;\n        localStorage.setItem(KEY, JSON.stringify(arr.slice(-500)));\n    } catch  {\n    // offline-safe: best-effort only\n    }\n}\nfunction enqueueObs(evt) {\n    const arr = load();\n    arr.push(evt);\n    save(arr);\n}\nfunction peekObs(limit = 100) {\n    return load().slice(0, limit);\n}\nfunction dropObs(ids) {\n    const arr = load().filter((e)=>!ids.includes(e.eventId));\n    save(arr);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi9zY2luZy9vYnMvb2JzQ2xpZW50UXVldWUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUEsTUFBTUEsTUFBTTtBQUVaLFNBQVNDO0lBQ1AsSUFBSTtRQUNGLElBQUksT0FBT0MsaUJBQWlCLGFBQWEsT0FBTyxFQUFFO1FBQ2xELE1BQU1DLE1BQU1ELGFBQWFFLE9BQU8sQ0FBQ0o7UUFDakMsSUFBSSxDQUFDRyxLQUFLLE9BQU8sRUFBRTtRQUNuQixNQUFNRSxNQUFNQyxLQUFLQyxLQUFLLENBQUNKO1FBQ3ZCLE9BQU9LLE1BQU1DLE9BQU8sQ0FBQ0osT0FBT0EsTUFBTSxFQUFFO0lBQ3RDLEVBQUUsT0FBTTtRQUNOLE9BQU8sRUFBRTtJQUNYO0FBQ0Y7QUFFQSxTQUFTSyxLQUFLTCxHQUFlO0lBQzNCLElBQUk7UUFDRixJQUFJLE9BQU9ILGlCQUFpQixhQUFhO1FBQ3pDQSxhQUFhUyxPQUFPLENBQUNYLEtBQUtNLEtBQUtNLFNBQVMsQ0FBQ1AsSUFBSVEsS0FBSyxDQUFDLENBQUM7SUFDdEQsRUFBRSxPQUFNO0lBQ04saUNBQWlDO0lBQ25DO0FBQ0Y7QUFFTyxTQUFTQyxXQUFXQyxHQUFhO0lBQ3RDLE1BQU1WLE1BQU1KO0lBQ1pJLElBQUlXLElBQUksQ0FBQ0Q7SUFDVEwsS0FBS0w7QUFDUDtBQUVPLFNBQVNZLFFBQVFDLFFBQWdCLEdBQUc7SUFDekMsT0FBT2pCLE9BQU9ZLEtBQUssQ0FBQyxHQUFHSztBQUN6QjtBQUVPLFNBQVNDLFFBQVFDLEdBQWE7SUFDbkMsTUFBTWYsTUFBTUosT0FBT29CLE1BQU0sQ0FBQyxDQUFDQyxJQUFNLENBQUNGLElBQUlHLFFBQVEsQ0FBQ0QsRUFBRUUsT0FBTztJQUN4RGQsS0FBS0w7QUFDUCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtYXN0ZVxcU0NJTkdPU19XT1JLXFxTY2luZ09TXFxzY2luZ1xcb2JzXFxvYnNDbGllbnRRdWV1ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE9ic0V2ZW50IH0gZnJvbSAnLi9vYnNUeXBlcyc7XG5cbmNvbnN0IEtFWSA9ICdzY2luZ19vYnNfcXVldWVfdjEnO1xuXG5mdW5jdGlvbiBsb2FkKCk6IE9ic0V2ZW50W10ge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHJhdyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKEtFWSk7XG4gICAgaWYgKCFyYXcpIHJldHVybiBbXTtcbiAgICBjb25zdCBhcnIgPSBKU09OLnBhcnNlKHJhdyk7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSA/IGFyciA6IFtdO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gc2F2ZShhcnI6IE9ic0V2ZW50W10pIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShLRVksIEpTT04uc3RyaW5naWZ5KGFyci5zbGljZSgtNTAwKSkpO1xuICB9IGNhdGNoIHtcbiAgICAvLyBvZmZsaW5lLXNhZmU6IGJlc3QtZWZmb3J0IG9ubHlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5xdWV1ZU9icyhldnQ6IE9ic0V2ZW50KSB7XG4gIGNvbnN0IGFyciA9IGxvYWQoKTtcbiAgYXJyLnB1c2goZXZ0KTtcbiAgc2F2ZShhcnIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGVla09icyhsaW1pdDogbnVtYmVyID0gMTAwKTogT2JzRXZlbnRbXSB7XG4gIHJldHVybiBsb2FkKCkuc2xpY2UoMCwgbGltaXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJvcE9icyhpZHM6IHN0cmluZ1tdKSB7XG4gIGNvbnN0IGFyciA9IGxvYWQoKS5maWx0ZXIoKGUpID0+ICFpZHMuaW5jbHVkZXMoZS5ldmVudElkKSk7XG4gIHNhdmUoYXJyKTtcbn1cbiJdLCJuYW1lcyI6WyJLRVkiLCJsb2FkIiwibG9jYWxTdG9yYWdlIiwicmF3IiwiZ2V0SXRlbSIsImFyciIsIkpTT04iLCJwYXJzZSIsIkFycmF5IiwiaXNBcnJheSIsInNhdmUiLCJzZXRJdGVtIiwic3RyaW5naWZ5Iiwic2xpY2UiLCJlbnF1ZXVlT2JzIiwiZXZ0IiwicHVzaCIsInBlZWtPYnMiLCJsaW1pdCIsImRyb3BPYnMiLCJpZHMiLCJmaWx0ZXIiLCJlIiwiaW5jbHVkZXMiLCJldmVudElkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../scing/obs/obsClientQueue.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/../scing/obs/obsIds.ts":
/*!******************************!*\
  !*** ../scing/obs/obsIds.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   correlationId: () => (/* binding */ correlationId),\n/* harmony export */   eventId: () => (/* binding */ eventId)\n/* harmony export */ });\nfunction correlationId(prefix = 'corr') {\n    const r = Math.random().toString(16).slice(2);\n    return `${prefix}_${Date.now()}_${r}`;\n}\nfunction eventId(prefix = 'obs') {\n    const r = Math.random().toString(16).slice(2);\n    return `${prefix}_${Date.now()}_${r}`;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi9zY2luZy9vYnMvb2JzSWRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU8sU0FBU0EsY0FBY0MsU0FBaUIsTUFBTTtJQUNuRCxNQUFNQyxJQUFJQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxLQUFLLENBQUM7SUFDM0MsT0FBTyxHQUFHTCxPQUFPLENBQUMsRUFBRU0sS0FBS0MsR0FBRyxHQUFHLENBQUMsRUFBRU4sR0FBRztBQUN2QztBQUVPLFNBQVNPLFFBQVFSLFNBQWlCLEtBQUs7SUFDNUMsTUFBTUMsSUFBSUMsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsS0FBSyxDQUFDO0lBQzNDLE9BQU8sR0FBR0wsT0FBTyxDQUFDLEVBQUVNLEtBQUtDLEdBQUcsR0FBRyxDQUFDLEVBQUVOLEdBQUc7QUFDdkMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFzdGVcXFNDSU5HT1NfV09SS1xcU2NpbmdPU1xcc2NpbmdcXG9ic1xcb2JzSWRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBjb3JyZWxhdGlvbklkKHByZWZpeDogc3RyaW5nID0gJ2NvcnInKTogc3RyaW5nIHtcbiAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnNsaWNlKDIpO1xuICByZXR1cm4gYCR7cHJlZml4fV8ke0RhdGUubm93KCl9XyR7cn1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZlbnRJZChwcmVmaXg6IHN0cmluZyA9ICdvYnMnKTogc3RyaW5nIHtcbiAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnNsaWNlKDIpO1xuICByZXR1cm4gYCR7cHJlZml4fV8ke0RhdGUubm93KCl9XyR7cn1gO1xufVxuIl0sIm5hbWVzIjpbImNvcnJlbGF0aW9uSWQiLCJwcmVmaXgiLCJyIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJEYXRlIiwibm93IiwiZXZlbnRJZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../scing/obs/obsIds.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/../scing/obs/obsLogger.ts":
/*!*********************************!*\
  !*** ../scing/obs/obsLogger.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeObsEvent: () => (/* binding */ makeObsEvent)\n/* harmony export */ });\n/* harmony import */ var _obsIds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./obsIds */ \"(pages-dir-browser)/../scing/obs/obsIds.ts\");\n/* harmony import */ var _obsRedact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./obsRedact */ \"(pages-dir-browser)/../scing/obs/obsRedact.ts\");\n\n\nfunction makeObsEvent(params) {\n    const err = params.error;\n    return {\n        eventId: (0,_obsIds__WEBPACK_IMPORTED_MODULE_0__.eventId)('obs'),\n        createdAt: new Date().toISOString(),\n        orgId: params.orgId,\n        uid: params.uid,\n        deviceId: params.deviceId,\n        severity: params.severity,\n        scope: params.scope,\n        correlationId: params.correlationId ?? (0,_obsIds__WEBPACK_IMPORTED_MODULE_0__.correlationId)('corr'),\n        inspectionId: params.inspectionId,\n        engineId: params.engineId,\n        phase: params.phase,\n        message: params.message,\n        errorName: err?.name,\n        errorStack: (0,_obsRedact__WEBPACK_IMPORTED_MODULE_1__.safeStack)(err?.stack),\n        tags: params.tags ?? [],\n        meta: (0,_obsRedact__WEBPACK_IMPORTED_MODULE_1__.redact)(params.meta ?? null),\n        offlineCaptured: params.offlineCaptured ?? false\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi9zY2luZy9vYnMvb2JzTG9nZ2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUNzRjtBQUN0QztBQUV6QyxTQUFTTSxhQUFhQyxNQWU1QjtJQUNDLE1BQU1DLE1BQU1ELE9BQU9FLEtBQUs7SUFDeEIsT0FBTztRQUNMVCxTQUFTQyxnREFBV0EsQ0FBQztRQUNyQlMsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1FBQ2pDQyxPQUFPTixPQUFPTSxLQUFLO1FBQ25CQyxLQUFLUCxPQUFPTyxHQUFHO1FBQ2ZDLFVBQVVSLE9BQU9RLFFBQVE7UUFDekJDLFVBQVVULE9BQU9TLFFBQVE7UUFDekJDLE9BQU9WLE9BQU9VLEtBQUs7UUFDbkJmLGVBQWVLLE9BQU9MLGFBQWEsSUFBSUMsc0RBQWlCQSxDQUFDO1FBQ3pEZSxjQUFjWCxPQUFPVyxZQUFZO1FBQ2pDQyxVQUFVWixPQUFPWSxRQUFRO1FBQ3pCQyxPQUFPYixPQUFPYSxLQUFLO1FBQ25CQyxTQUFTZCxPQUFPYyxPQUFPO1FBQ3ZCQyxXQUFXZCxLQUFLZTtRQUNoQkMsWUFBWW5CLHFEQUFTQSxDQUFDRyxLQUFLaUI7UUFDM0JDLE1BQU1uQixPQUFPbUIsSUFBSSxJQUFJLEVBQUU7UUFDdkJDLE1BQU12QixrREFBTUEsQ0FBQ0csT0FBT29CLElBQUksSUFBSTtRQUM1QkMsaUJBQWlCckIsT0FBT3FCLGVBQWUsSUFBSTtJQUM3QztBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG1hc3RlXFxTQ0lOR09TX1dPUktcXFNjaW5nT1NcXHNjaW5nXFxvYnNcXG9ic0xvZ2dlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE9ic0V2ZW50LCBPYnNTY29wZSwgT2JzU2V2ZXJpdHkgfSBmcm9tICcuL29ic1R5cGVzJztcbmltcG9ydCB7IGV2ZW50SWQgYXMgbWFrZUV2ZW50SWQsIGNvcnJlbGF0aW9uSWQgYXMgbWFrZUNvcnJlbGF0aW9uSWQgfSBmcm9tICcuL29ic0lkcyc7XG5pbXBvcnQgeyByZWRhY3QsIHNhZmVTdGFjayB9IGZyb20gJy4vb2JzUmVkYWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VPYnNFdmVudChwYXJhbXM6IHtcbiAgc2V2ZXJpdHk6IE9ic1NldmVyaXR5O1xuICBzY29wZTogT2JzU2NvcGU7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgb3JnSWQ/OiBzdHJpbmc7XG4gIHVpZD86IHN0cmluZztcbiAgZGV2aWNlSWQ/OiBzdHJpbmc7XG4gIGluc3BlY3Rpb25JZD86IHN0cmluZztcbiAgZW5naW5lSWQ/OiBzdHJpbmc7XG4gIHBoYXNlPzogc3RyaW5nO1xuICBjb3JyZWxhdGlvbklkPzogc3RyaW5nO1xuICBlcnJvcj86IGFueTtcbiAgbWV0YT86IGFueTtcbiAgdGFncz86IHN0cmluZ1tdO1xuICBvZmZsaW5lQ2FwdHVyZWQ/OiBib29sZWFuO1xufSk6IE9ic0V2ZW50IHtcbiAgY29uc3QgZXJyID0gcGFyYW1zLmVycm9yO1xuICByZXR1cm4ge1xuICAgIGV2ZW50SWQ6IG1ha2VFdmVudElkKCdvYnMnKSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBvcmdJZDogcGFyYW1zLm9yZ0lkLFxuICAgIHVpZDogcGFyYW1zLnVpZCxcbiAgICBkZXZpY2VJZDogcGFyYW1zLmRldmljZUlkLFxuICAgIHNldmVyaXR5OiBwYXJhbXMuc2V2ZXJpdHksXG4gICAgc2NvcGU6IHBhcmFtcy5zY29wZSxcbiAgICBjb3JyZWxhdGlvbklkOiBwYXJhbXMuY29ycmVsYXRpb25JZCA/PyBtYWtlQ29ycmVsYXRpb25JZCgnY29ycicpLFxuICAgIGluc3BlY3Rpb25JZDogcGFyYW1zLmluc3BlY3Rpb25JZCxcbiAgICBlbmdpbmVJZDogcGFyYW1zLmVuZ2luZUlkLFxuICAgIHBoYXNlOiBwYXJhbXMucGhhc2UsXG4gICAgbWVzc2FnZTogcGFyYW1zLm1lc3NhZ2UsXG4gICAgZXJyb3JOYW1lOiBlcnI/Lm5hbWUsXG4gICAgZXJyb3JTdGFjazogc2FmZVN0YWNrKGVycj8uc3RhY2spLFxuICAgIHRhZ3M6IHBhcmFtcy50YWdzID8/IFtdLFxuICAgIG1ldGE6IHJlZGFjdChwYXJhbXMubWV0YSA/PyBudWxsKSxcbiAgICBvZmZsaW5lQ2FwdHVyZWQ6IHBhcmFtcy5vZmZsaW5lQ2FwdHVyZWQgPz8gZmFsc2UsXG4gIH07XG59XG4iXSwibmFtZXMiOlsiZXZlbnRJZCIsIm1ha2VFdmVudElkIiwiY29ycmVsYXRpb25JZCIsIm1ha2VDb3JyZWxhdGlvbklkIiwicmVkYWN0Iiwic2FmZVN0YWNrIiwibWFrZU9ic0V2ZW50IiwicGFyYW1zIiwiZXJyIiwiZXJyb3IiLCJjcmVhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJvcmdJZCIsInVpZCIsImRldmljZUlkIiwic2V2ZXJpdHkiLCJzY29wZSIsImluc3BlY3Rpb25JZCIsImVuZ2luZUlkIiwicGhhc2UiLCJtZXNzYWdlIiwiZXJyb3JOYW1lIiwibmFtZSIsImVycm9yU3RhY2siLCJzdGFjayIsInRhZ3MiLCJtZXRhIiwib2ZmbGluZUNhcHR1cmVkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../scing/obs/obsLogger.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/../scing/obs/obsRedact.ts":
/*!*********************************!*\
  !*** ../scing/obs/obsRedact.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   redact: () => (/* binding */ redact),\n/* harmony export */   safeStack: () => (/* binding */ safeStack)\n/* harmony export */ });\nconst SECRET_KEYS = new Set([\n    'password',\n    'pass',\n    'token',\n    'idToken',\n    'accessToken',\n    'refreshToken',\n    'apiKey',\n    'secret',\n    'privateKey',\n    'authorization'\n]);\nfunction redact(value) {\n    if (value == null) return value;\n    if (typeof value === 'string') {\n        // strip obvious bearer tokens\n        return value.replace(/Bearer\\s+[A-Za-z0-9\\-\\._~\\+\\/]+=*/g, 'Bearer [REDACTED]');\n    }\n    if (Array.isArray(value)) return value.map(redact);\n    if (typeof value === 'object') {\n        const out = {};\n        for (const [k, v] of Object.entries(value)){\n            if (SECRET_KEYS.has(k)) out[k] = '[REDACTED]';\n            else out[k] = redact(v);\n        }\n        return out;\n    }\n    return value;\n}\nfunction safeStack(stack) {\n    if (!stack) return stack;\n    // keep stack but remove query strings that might include tokens\n    return stack.replace(/\\?.*$/gm, '?[REDACTED_QS]');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi9zY2luZy9vYnMvb2JzUmVkYWN0LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsTUFBTUEsY0FBYyxJQUFJQyxJQUFJO0lBQzFCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFTSxTQUFTQyxPQUFPQyxLQUFVO0lBQy9CLElBQUlBLFNBQVMsTUFBTSxPQUFPQTtJQUMxQixJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUM3Qiw4QkFBOEI7UUFDOUIsT0FBT0EsTUFBTUMsT0FBTyxDQUFDLHNDQUFzQztJQUM3RDtJQUNBLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsUUFBUSxPQUFPQSxNQUFNSSxHQUFHLENBQUNMO0lBQzNDLElBQUksT0FBT0MsVUFBVSxVQUFVO1FBQzdCLE1BQU1LLE1BQVcsQ0FBQztRQUNsQixLQUFLLE1BQU0sQ0FBQ0MsR0FBR0MsRUFBRSxJQUFJQyxPQUFPQyxPQUFPLENBQUNULE9BQVE7WUFDMUMsSUFBSUgsWUFBWWEsR0FBRyxDQUFDSixJQUFJRCxHQUFHLENBQUNDLEVBQUUsR0FBRztpQkFDNUJELEdBQUcsQ0FBQ0MsRUFBRSxHQUFHUCxPQUFPUTtRQUN2QjtRQUNBLE9BQU9GO0lBQ1Q7SUFDQSxPQUFPTDtBQUNUO0FBRU8sU0FBU1csVUFBVUMsS0FBYztJQUN0QyxJQUFJLENBQUNBLE9BQU8sT0FBT0E7SUFDbkIsZ0VBQWdFO0lBQ2hFLE9BQU9BLE1BQU1YLE9BQU8sQ0FBQyxXQUFXO0FBQ2xDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG1hc3RlXFxTQ0lOR09TX1dPUktcXFNjaW5nT1NcXHNjaW5nXFxvYnNcXG9ic1JlZGFjdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTRUNSRVRfS0VZUyA9IG5ldyBTZXQoW1xuICAncGFzc3dvcmQnLFxuICAncGFzcycsXG4gICd0b2tlbicsXG4gICdpZFRva2VuJyxcbiAgJ2FjY2Vzc1Rva2VuJyxcbiAgJ3JlZnJlc2hUb2tlbicsXG4gICdhcGlLZXknLFxuICAnc2VjcmV0JyxcbiAgJ3ByaXZhdGVLZXknLFxuICAnYXV0aG9yaXphdGlvbicsXG5dKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZGFjdCh2YWx1ZTogYW55KTogYW55IHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBzdHJpcCBvYnZpb3VzIGJlYXJlciB0b2tlbnNcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvQmVhcmVyXFxzK1tBLVphLXowLTlcXC1cXC5fflxcK1xcL10rPSovZywgJ0JlYXJlciBbUkVEQUNURURdJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWUubWFwKHJlZGFjdCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3Qgb3V0OiBhbnkgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgIGlmIChTRUNSRVRfS0VZUy5oYXMoaykpIG91dFtrXSA9ICdbUkVEQUNURURdJztcbiAgICAgIGVsc2Ugb3V0W2tdID0gcmVkYWN0KHYpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVTdGFjayhzdGFjaz86IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmICghc3RhY2spIHJldHVybiBzdGFjaztcbiAgLy8ga2VlcCBzdGFjayBidXQgcmVtb3ZlIHF1ZXJ5IHN0cmluZ3MgdGhhdCBtaWdodCBpbmNsdWRlIHRva2Vuc1xuICByZXR1cm4gc3RhY2sucmVwbGFjZSgvXFw/LiokL2dtLCAnP1tSRURBQ1RFRF9RU10nKTtcbn1cbiJdLCJuYW1lcyI6WyJTRUNSRVRfS0VZUyIsIlNldCIsInJlZGFjdCIsInZhbHVlIiwicmVwbGFjZSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIm91dCIsImsiLCJ2IiwiT2JqZWN0IiwiZW50cmllcyIsImhhcyIsInNhZmVTdGFjayIsInN0YWNrIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../scing/obs/obsRedact.ts\n"));

/***/ })

});