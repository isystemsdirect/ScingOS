import https from "https";
import { mkdirSync, writeFileSync, existsSync, readFileSync } from "fs";
import { join } from "path";
import os from "os";
import { exec } from "child_process";

const USE_HTTPS = process.env.HTTPS !== "false"; // Enable HTTPS by default
const PORT = process.env.PORT ? Number(process.env.PORT) : (USE_HTTPS ? 9443 : 8088);
const UPLOAD_DIR = join(process.cwd(), "uploads");
const CERT_DIR = join(process.cwd(), "certs");
const CERT_FILE = join(CERT_DIR, "server.crt");
const KEY_FILE = join(CERT_DIR, "server.key");

if (!existsSync(UPLOAD_DIR)) mkdirSync(UPLOAD_DIR, { recursive: true });
if (!existsSync(CERT_DIR)) mkdirSync(CERT_DIR, { recursive: true });

// Ensure HTTPS certificate exists (self-signed)
function ensureCertificate() {
  if (existsSync(CERT_FILE) && existsSync(KEY_FILE)) {
    console.log("[CERT] Using existing certificate");
    return true;
  }
  
  if (!USE_HTTPS) return false;
  
  console.log("[CERT] Generating self-signed certificate...");
  const cmd = `openssl req -x509 -newkey rsa:2048 -keyout "${KEY_FILE}" -out "${CERT_FILE}" -days 1825 -nodes -subj "/CN=spectrocap.local"`;
  
  try {
    // Check if openssl is available (Windows Git Bash, WSL, or Linux)
    require('child_process').execSync(cmd, { stdio: 'pipe' });
    console.log("[CERT] Self-signed certificate created");
    return true;
  } catch (e) {
    console.warn("[CERT] Could not create certificate (openssl not found). Falling back to HTTP.");
    return false;
  }
}

const CLIP_FILE = join(process.cwd(), "clipboard.json");
let lastClip = { text: "", ts: 0, from: "" };

function loadClip() {
  try {
    if (existsSync(CLIP_FILE)) {
      const j = JSON.parse(require("fs").readFileSync(CLIP_FILE, "utf8"));
      if (j && typeof j.text === "string") lastClip = j;
    }
  } catch {}
}
function saveClip() {
  try { writeFileSync(CLIP_FILE, JSON.stringify(lastClip), "utf8"); } catch {}
}
loadClip();

function getLanIPs() {
  const ifaces = os.networkInterfaces();
  const ips = [];
  for (const name of Object.keys(ifaces)) {
    for (const i of (ifaces[name] || [])) {
      if (i && i.family === "IPv4" && !i.internal) ips.push(i.address);
    }
  }
  return ips;
}

function send(res, code, obj) {
  const body = JSON.stringify(obj);
  res.writeHead(code, {
    "Content-Type": "application/json",
    "Content-Length": Buffer.byteLength(body)
  });
  res.end(body);
}

const server = http.createServer((req, res) => {
  if (req.method === "GET" && req.url === "/health") {
    return send(res, 200, { ok: true, ts: Date.now(), port: PORT, ips: getLanIPs() });
  }

  if (req.method === "POST" && req.url === "/ingest") {
    let raw = "";
    req.on("data", (c) => (raw += c));
    req.on("end", () => {
      try {
        const j = JSON.parse(raw || "{}");
        const id = j.id || `cap_${Date.now()}`;
        const b64 = j.pngBase64 || "";
        if (!b64) return send(res, 400, { ok: false, error: "Missing pngBase64" });

        const buf = Buffer.from(b64, "base64");
        const out = join(UPLOAD_DIR, `${id}.png`);
        writeFileSync(out, buf);

        return send(res, 200, { ok: true, saved: out, bytes: buf.length });
      } catch (e) {
        return send(res, 400, { ok: false, error: String(e) });
      }
    });
    return;
  }

  // Clipboard: push from phone/app
  if (req.method === "POST" && req.url === "/clip/push") {
    let raw = "";
    req.on("data", (c) => (raw += c));
    req.on("end", () => {
      try {
        const j = JSON.parse(raw || "{}");
        const text = (j.text || "").toString();
        const from = (j.from || "unknown").toString();
        if (!text) return send(res, 400, { ok: false, error: "Missing text" });

        lastClip = { text, ts: Date.now(), from };
        saveClip();
        console.log(`[CLIP] Pushed from ${from}: ${text.substring(0, 50)}...`);
        return send(res, 200, { ok: true, ts: lastClip.ts, from: lastClip.from, length: lastClip.text.length });
      } catch (e) {
        return send(res, 400, { ok: false, error: String(e) });
      }
    });
    return;
  }

  // Clipboard: pull for Windows client
  if (req.method === "GET" && req.url === "/clip/pull") {
    return send(res, 200, { ok: true, ...lastClip });
  }

  // Clipboard: clear
  if (req.method === "POST" && req.url === "/clip/clear") {
    lastClip = { text: "", ts: Date.now(), from: "cleared" };
    saveClip();
    console.log("[CLIP] Cleared");
    return send(res, 200, { ok: true });
  }

  send(res, 404, { ok: false, error: "Not found" });
});

// Create HTTPS or HTTP server based on configuration
let server;
let protocol = "http";

if (USE_HTTPS && ensureCertificate()) {
  try {
    const options = {
      key: readFileSync(KEY_FILE, 'utf8'),
      cert: readFileSync(CERT_FILE, 'utf8')
    };
    server = https.createServer(options, (req, res) => {
      const handler = httpHandler(req, res);
      if (handler !== undefined) return handler;
    });
    protocol = "https";
    console.log("[CERT] HTTPS server configured");
  } catch (e) {
    console.error("[CERT] HTTPS setup failed, falling back to HTTP:", e.message);
    server = http.createServer(httpHandler);
    import('http').then(m => { server = m.default.createServer(httpHandler); });
  }
} else {
  import('http').then(m => { server = m.default.createServer(httpHandler); });
}

// HTTP handler function (extracted for reuse)
function httpHandler(req, res) {
  if (req.method === "GET" && req.url === "/health") {
    return send(res, 200, { ok: true, ts: Date.now(), port: PORT, ips: getLanIPs(), protocol: protocol });
  }

  if (req.method === "POST" && req.url === "/ingest") {
    let raw = "";
    req.on("data", (c) => (raw += c));
    req.on("end", () => {
      try {
        const j = JSON.parse(raw || "{}");
        const id = j.id || `cap_${Date.now()}`;
        const b64 = j.pngBase64 || "";
        if (!b64) return send(res, 400, { ok: false, error: "Missing pngBase64" });

        const buf = Buffer.from(b64, "base64");
        const out = join(UPLOAD_DIR, `${id}.png`);
        writeFileSync(out, buf);

        return send(res, 200, { ok: true, saved: out, bytes: buf.length });
      } catch (e) {
        return send(res, 400, { ok: false, error: String(e) });
      }
    });
    return;
  }

  // Clipboard: push from phone/app
  if (req.method === "POST" && req.url === "/clip/push") {
    let raw = "";
    req.on("data", (c) => (raw += c));
    req.on("end", () => {
      try {
        const j = JSON.parse(raw || "{}");
        const text = (j.text || "").toString();
        const from = (j.from || "unknown").toString();
        if (!text) return send(res, 400, { ok: false, error: "Missing text" });

        lastClip = { text, ts: Date.now(), from };
        saveClip();
        console.log(`[CLIP] Pushed from ${from}: ${text.substring(0, 50)}...`);
        return send(res, 200, { ok: true, ts: lastClip.ts, from: lastClip.from, length: lastClip.text.length });
      } catch (e) {
        return send(res, 400, { ok: false, error: String(e) });
      }
    });
    return;
  }

  // Clipboard: pull for Windows client
  if (req.method === "GET" && req.url === "/clip/pull") {
    return send(res, 200, { ok: true, ...lastClip });
  }

  // Clipboard: clear
  if (req.method === "POST" && req.url === "/clip/clear") {
    lastClip = { text: "", ts: Date.now(), from: "cleared" };
    saveClip();
    console.log("[CLIP] Cleared");
    return send(res, 200, { ok: true });
  }

  send(res, 404, { ok: false, error: "Not found" });
}

server.listen(PORT, "0.0.0.0", () => {
  console.log(`\n╔════════════════════════════════════════════════════════╗`);
  console.log(`║ SpectroCAP Receiver (${protocol.toUpperCase()})                         ║`);
  console.log(`╚════════════════════════════════════════════════════════╝\n`);
  console.log(`Protocol:  ${protocol.toUpperCase()}`);
  console.log(`Port:      ${PORT}`);
  console.log(`Health:    ${protocol}://localhost:${PORT}/health`);
  console.log(`Ingest:    ${protocol}://<LAN-IP>:${PORT}/ingest`);
  console.log(`Clip:      ${protocol}://<LAN-IP>:${PORT}/clip/push|pull|clear`);
  console.log(`LAN IPs:   ${getLanIPs().join(", ") || "(none)"}`);
  console.log(`Uploads:   ${UPLOAD_DIR}`);
  console.log(`Clipboard: ${CLIP_FILE}`);
  if (USE_HTTPS && protocol === "https") {
    console.log(`Cert:      ${CERT_FILE}`);
    console.log(`Key:       ${KEY_FILE}`);
  }
  console.log("");
});

